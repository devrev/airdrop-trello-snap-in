{
    "1.1": {
        "folder_name": "conformance_tests/health_check_invocation_tests",
        "functional_requirement": "- Implement :Function: \"health_check\" that only checks if :Function: can be invoked.",
        "test_summary": [
            {
                "test_name": "health_check_function_invocation_success",
                "test_contents": "This test verifies the basic invocability of the health_check function. It creates a base event payload with a unique request ID ('test-request-id-001') and function name 'health_check', sends a synchronous request to the snap-in server at http://localhost:8000/handle/sync, and asserts that the response status code is 200 (HTTP OK). This confirms that the function can be successfully invoked without errors."
            },
            {
                "test_name": "health_check_function_response_structure",
                "test_contents": "This test validates the structure and content of the health_check function's response. It sends a request with request ID 'test-request-id-002' and verifies that: (1) the response has HTTP status 200, (2) the response contains a 'function_result' object, (3) the function_result contains a 'success' field set to true, (4) the function_result contains a non-empty 'message' string field, (5) the function_result contains a 'function_name' field that matches the requested function name ('health_check'), and (6) the function_result contains a 'request_id' field that matches the request ID sent in the payload. This ensures the response adheres to the expected contract."
            },
            {
                "test_name": "health_check_function_processes_first_event_only",
                "test_contents": "This test confirms that the health_check function correctly processes a single event and returns appropriate metadata from that event. It sends a request with request ID 'test-request-id-003' and function name 'health_check', then verifies that: (1) the response status is 200, (2) the function_result.success is true, (3) the function_result.function_name matches the sent function name, (4) the function_result.request_id matches the sent request ID, and (5) a valid message string is present in the response. This test ensures that the function processes the event payload correctly and includes the event's metadata in its response."
            }
        ]
    },
    "2.1.1": {
        "folder_name": "conformance_tests/fetch_boards_tests",
        "functional_requirement": "- Implement the :Function: \"fetch_boards\" that fetches all boards as specified in :ObjectPRD: `[resource]boards-extraction.md` using :NonPaginationRule:.",
        "acceptance_tests": [
            "- Test :Function: \"fetch_boards\" (`:= fetch_boards_response`)\n  - Expect `len(fetch_boards_response.boards)==4`.\n  - From `fetch_boards_response` (array of objects), find board with name \"2025-10-10 - Board with 12 cards\" (`:= specific_board`). Expect:\n    - `specific_board` to exist.\n    - `specific_board.id==\"68e8befbf2f641caa9b1e275\"`.\n    - `specific_board.desc==\"\"`.\n    - `specific_board.item_type==\"cards\"`.",
            "- Test the rate limiting of :Function: \"fetch_boards\" with the following flow:\n  - Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Invoke :Function: \"fetch_boards\" with valid credentials and all required parameters.\n  - Expect: `status_code = 429`.\n  - Expect: `api_delay > 0` and `api_delay <= 3`. If api_delay is bigger than 3, assume the problem is that we did not calculate the api_delay correctly in :Implementation:."
        ],
        "test_summary": [
            {
                "test_name": "fetch_boards_function_invocation_success",
                "test_contents": "Validates that the fetch_boards function can be successfully invoked with valid Trello credentials (API key, OAuth token, and organization ID). The test creates a properly formatted event payload with connection data and sends it to the snap-in server at http://localhost:8000/handle/sync. Success criteria: HTTP 200 response status, presence of response data, and absence of error fields in the response."
            },
            {
                "test_name": "fetch_boards_response_structure",
                "test_contents": "Verifies that the fetch_boards function returns a response with the correct structure and required fields. The test checks for: (1) HTTP 200 status code, (2) presence of function_result object, (3) status_code field set to 200, (4) api_delay field set to 0 (indicating no rate limiting), (5) message field as a non-empty string, and (6) data field containing the boards array. This ensures the response conforms to the expected contract."
            },
            {
                "test_name": "fetch_boards_returns_array_of_boards",
                "test_contents": "Validates that the fetch_boards function returns an array of boards with the correct format according to the ObjectPRD specification. The test verifies: (1) data field is an array, (2) array is not empty, (3) each board object contains required fields: id (string), name (string), description (string), and item_type (fixed value 'cards'). This ensures boards are properly extracted and formatted from the Trello API response."
            },
            {
                "test_name": "fetch_boards_specific_requirements",
                "test_contents": "Acceptance test that validates specific data requirements against known test data in the Trello organization. The test verifies: (1) exactly 4 boards are returned, (2) a board named '2025-10-10 - Board with 12 cards' exists in the results, (3) that specific board has ID '68e8befbf2f641caa9b1e275', (4) that specific board has an empty description (empty string), and (5) that specific board has item_type set to 'cards'. This test ensures the implementation correctly extracts and maps real Trello board data."
            },
            {
                "test_name": "fetch_boards_rate_limiting",
                "test_contents": "Tests the function's ability to handle rate limiting (HTTP 429) responses from the Trello API. The test: (1) triggers rate limiting on a mock server at http://localhost:8004/start_rate_limiting with a unique test identifier, (2) invokes the fetch_boards function, (3) verifies the response contains status_code 429, (4) validates api_delay field exists and is a number, (5) confirms api_delay is greater than 0 and less than or equal to 3 seconds, and (6) checks for a descriptive message field. This ensures the implementation properly detects rate limiting, extracts the delay from the Retry-After header or API response, and returns appropriate metadata for retry logic."
            }
        ]
    },
    "2.1.2": {
        "folder_name": "conformance_tests/fetch_users_tests",
        "functional_requirement": "- Implement the :Function: \"fetch_users\" that fetches all users as specified in :ObjectPRD: `[resource]users-extraction.md` using :NonPaginationRule:.",
        "acceptance_tests": [
            "- Test :Function: \"fetch_users\" (`:= fetch_users_response`)\n  - Expect `len(fetch_users_response.users)==3`\n  - From `fetch_users_response` (array of objects), find user with \"id\" equal to \"6752eb529b14a3446b75e69c\" (`:= specific_user`). Expect:\n    - `specific_user` to exist.\n    - `specific_user.full_name==\"SaaS Connectors\"`.\n    - `specific_user.username==\"examplesaas1\"`.\n    - `specific_user.email==\"example+saas@codeplain.ai\"`.",
            "- Test the rate limiting of :Function: \"fetch_users\" with the following flow:\n  - Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Invoke :Function: \"fetch_users\" with valid credentials and all required parameters.\n  - Expect: `status_code = 429`.\n  - Expect: `api_delay > 0` and `api_delay <= 3`. If api_delay is bigger than 3, assume the problem is that we did not calculate the api_delay correctly in :Implementation:."
        ],
        "test_summary": [
            {
                "test_name": "fetch_users_function_invocation_success",
                "test_contents": "Validates that the fetch_users function can be successfully invoked with valid Trello credentials (API key, OAuth token, and organization ID). The test creates an event payload with credentials from environment variables, sends it to the snap-in server at http://localhost:8000/handle/sync, and verifies that: (1) the HTTP response status is 200, (2) response data is present and not null, and (3) no error fields exist in the response. This test confirms basic connectivity and authentication handling."
            },
            {
                "test_name": "fetch_users_response_structure",
                "test_contents": "Verifies that the fetch_users function returns a response with the correct structure and all required fields. After invoking the function with valid credentials, the test validates: (1) HTTP status code is 200, (2) a function_result object exists in the response, (3) function_result.status_code equals 200, (4) function_result.api_delay equals 0 (indicating no rate limiting), (5) function_result.message is a non-empty string, and (6) function_result.data is an array. This ensures the response adheres to the expected contract for successful user fetching operations."
            },
            {
                "test_name": "fetch_users_returns_array_of_users",
                "test_contents": "Validates that the fetch_users function returns an array of user objects with the correct format according to the ObjectPRD specification. The test invokes the function, verifies the response structure, and then iterates through each returned user to confirm: (1) the data field is a non-empty array, (2) each user has an 'id' field (non-empty string), (3) each user has a 'full_name' field (string), (4) each user has a 'username' field (non-empty string), and (5) each user has an 'email' field (string). This ensures compliance with the users-extraction.md ObjectPRD mapping requirements."
            },
            {
                "test_name": "fetch_users_returns_exactly_three_users_with_specific_user_data",
                "test_contents": "Performs an acceptance test that validates both the quantity and quality of returned user data. The test invokes fetch_users and verifies: (1) HTTP status is 200, (2) function_result.status_code is 200, (3) exactly 3 users are returned in the data array, and (4) a specific user with ID '6752eb529b14a3446b75e69c' exists with exact property values: full_name='SaaS Connectors', username='examplesaas1', and email='example+saas@codeplain.ai'. If the expected user count or specific user properties don't match, the test provides detailed error messages including available user IDs for debugging. This test validates real-world data extraction accuracy."
            },
            {
                "test_name": "fetch_users_handles_rate_limiting_correctly",
                "test_contents": "Tests the fetch_users function's ability to properly handle API rate limiting scenarios. The test first triggers rate limiting on the test server (http://localhost:8004/start_rate_limiting), then invokes fetch_users with valid credentials. It validates: (1) HTTP response status is 200 (snap-in server always returns 200), (2) function_result.status_code is 429 (indicating rate limiting was detected), (3) function_result.api_delay exists and is a number greater than 0, (4) api_delay is less than or equal to 3 seconds (the expected default or extracted value from Retry-After header), and (5) function_result.message contains 'rate limit' text. The test includes detailed error messages to help diagnose issues with rate limiting detection and delay calculation in TrelloClient methods."
            }
        ]
    },
    "2.1.3": {
        "folder_name": "conformance_tests/fetch_labels_tests",
        "functional_requirement": "- Implement the :Function: \"fetch_labels\" that fetches all labels as specified in :ObjectPRD: `[resource]labels-extraction.md` using :NonPaginationRule:.",
        "acceptance_tests": [
            "- Test :Function: \"fetch_labels\" (`:= fetch_labels_response`)\n  - Expect `len(fetch_labels_response.labels)==6`\n  - From `fetch_labels_response` (array of objects), find label with \"name\" equal to \"label-blue\" (`:= specific_label`). Expect:\n    - specific_label to exist.\n    - `specific_label.name==\"label-blue\"`.\n    - `specific_label.color==\"#0000FF\"`.\n    - `specific_label.description==\"label-blue\"`.",
            "- Test the rate limiting of :Function: \"fetch_labels\" with the following flow:\n  - Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Invoke :Function: \"fetch_labels\" with valid credentials and all required parameters.\n  - Expect: `status_code = 429`.\n  - Expect: `api_delay > 0` and `api_delay <= 3`. If api_delay is bigger than 3, assume the problem is that we did not calculate the api_delay correctly in :Implementation:."
        ],
        "test_summary": [
            {
                "test_name": "fetch_labels_successfully_fetches_and_validates_labels",
                "test_contents": "This test validates the successful fetching and normalization of labels from the Trello API. It performs the following validations:\n\n1. **Setup**: Reads Trello credentials (API key, OAuth token, organization ID) from environment variables and constructs a valid event payload with board ID '68e8befbf2f641caa9b1e275'.\n\n2. **Invocation**: Sends a POST request to the snap-in server at http://localhost:8000/handle/sync with the fetch_labels function payload.\n\n3. **Response Validation**:\n   - Verifies HTTP 200 status code\n   - Confirms function_result exists in response\n   - Validates function_result.status_code is 200\n   - Ensures function_result.data is an array\n   - Verifies exactly 6 labels are returned\n\n4. **Specific Label Validation**:\n   - Searches for a label with name 'label-blue'\n   - Validates the label has:\n     * name: 'label-blue'\n     * style: '#0000FF' (hex color code for blue)\n     * description: 'label-blue'\n\n5. **Error Handling**: Logs detailed error information if the request fails or if the expected label is not found."
            },
            {
                "test_name": "fetch_labels_handles_rate_limiting_correctly",
                "test_contents": "This test validates that the fetch_labels function correctly handles rate limiting scenarios from the Trello API. It performs the following validations:\n\n1. **Setup**: Reads Trello credentials from environment variables and triggers rate limiting on a mock server (http://localhost:8004) by sending a start_rate_limiting request.\n\n2. **Event Payload**: Constructs a valid event payload with board ID '68e8befbf2f641caa9b1e275' and properly formatted connection data.\n\n3. **Invocation**: Sends a POST request to the snap-in server to invoke the fetch_labels function.\n\n4. **Rate Limit Response Validation**:\n   - Verifies HTTP 200 status code (the snap-in handles the error gracefully)\n   - Confirms function_result exists in response\n   - Validates function_result.status_code is 429 (rate limit detected)\n   - Ensures api_delay field exists and is a number\n   - Verifies api_delay is greater than 0 and less than or equal to 3 seconds\n   - Confirms a descriptive error message exists\n   - Validates the error message contains 'rate limit' (case-insensitive)\n\n5. **Error Handling**: Logs detailed error information if mock server setup fails or if the request fails."
            }
        ]
    },
    "2.1.4": {
        "folder_name": "conformance_tests/fetch_comments_tests",
        "functional_requirement": "- Implement the :Function: \"fetch_comments\" that fetches all comments as specified in :ObjectPRD: `[resource]comments-extraction.md` using :NonPaginationRule:\n  - TRELLO_CARD_ID is provided event[\"input_data\"][\"global_values\"][\"idCard\"]",
        "acceptance_tests": [
            "- Test :Function: \"fetch_comments\" (`:= fetch_comments_response`) for card with ID \"68e8befc8381b0efa25ce1eb\"\n  - Expect `len(fetch_comments_response.comments)==2`\n  - From `fetch_comments_response` (array of objects), find comment with \"id\" equal to \"6904f1f01ce07384a79c0ee3\" (`:= specific_comment`). Expect:\n    - `specific_comment` to exist.\n    - `specific_comment.id==\"6904f1f01ce07384a79c0ee3\"`.\n    - `specific_comment.body==\"Second comment\"`.\n    - `specific_comment.parent_object_id==\"68e8befc8381b0efa25ce1eb\"`.\n    - `specific_comment.creator_display_name==\"examplesaas1\"`.\n    - `specific_comment.grandparent_object_id==\"68e8befbf2f641caa9b1e275\"`.",
            "- Test the rate limiting of :Function: \"fetch_comments\" with the following flow:\n  - Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Invoke :Function: \"fetch_comments\" with valid credentials and all required parameters.\n  - Expect: `status_code = 429`.\n  - Expect: `api_delay > 0` and `api_delay <= 3`. If api_delay is bigger than 3, assume the problem is that we did not calculate the api_delay correctly in :Implementation:."
        ],
        "test_summary": [
            {
                "test_name": "fetch_comments_function_invocation_success",
                "test_contents": "Validates successful invocation of the fetch_comments function. Creates an event payload with card ID '68e8befc8381b0efa25ce1eb' in input_data.global_values.idCard, sends it to the snap-in server at http://localhost:8000/handle/sync, and verifies: (1) HTTP response status is 200, (2) response data is defined and not null, (3) no error field exists in the response. This test confirms basic connectivity and successful function execution with valid credentials."
            },
            {
                "test_name": "fetch_comments_response_structure",
                "test_contents": "Verifies the structure of the response returned by fetch_comments function. Sends a request with card ID '68e8befc8381b0efa25ce1eb' and validates: (1) HTTP status is 200, (2) function_result object exists in response, (3) function_result.status_code equals 200, (4) function_result.api_delay equals 0, (5) function_result.message is a non-empty string, (6) function_result.data is an array. This ensures the response adheres to the expected API contract."
            },
            {
                "test_name": "fetch_comments_returns_array_of_comments",
                "test_contents": "Validates that fetch_comments returns properly formatted comment objects according to ObjectPRD specification. For card ID '68e8befc8381b0efa25ce1eb', verifies each comment in the returned array contains: (1) id - non-empty string, (2) body - array of strings (rich text format), (3) parent_object_id - string, (4) created_by_id - string, (5) modified_date - string, (6) grandparent_object_id - string, (7) grandparent_object_type - fixed value 'board', (8) creator_display_name - string, (9) parent_object_type - fixed value 'issue'. This test ensures data normalization is correctly implemented."
            },
            {
                "test_name": "fetch_comments_acceptance_test_specific_card_validation",
                "test_contents": "Acceptance test that validates specific comment data for card '68e8befc8381b0efa25ce1eb'. Performs detailed assertions: (1) Exactly 2 comments are returned, (2) A specific comment with ID '6904f1f01ce07384a79c0ee3' exists, (3) The specific comment has body equal to ['Second comment'], (4) parent_object_id equals '68e8befc8381b0efa25ce1eb', (5) creator_display_name equals 'examplesaas1', (6) grandparent_object_id equals '68e8befbf2f641caa9b1e275'. This test validates end-to-end functionality with known test data and verifies exact field values match expected results."
            },
            {
                "test_name": "fetch_comments_rate_limiting_validation",
                "test_contents": "Validates rate limiting behavior for fetch_comments function. Test flow: (1) Triggers rate limiting by sending POST request to http://localhost:8004/start_rate_limiting with test_name identifier, (2) Invokes fetch_comments function with card ID '68e8befc8381b0efa25ce1eb', (3) Verifies function_result.status_code equals 429 (rate limited), (4) Verifies function_result.api_delay is greater than 0 and less than or equal to 3. This test ensures the function correctly handles rate limiting responses from the Trello API and properly extracts and returns the retry delay value."
            }
        ]
    },
    "2.1.5": {
        "folder_name": "conformance_tests/fetch_cards_tests",
        "functional_requirement": "- Implement the :Function: \"fetch_cards\" that fetches all cards as specified in :ObjectPRD: `[resource]cards-extraction.md` using :PaginationIterationRule:",
        "acceptance_tests": [
            "- Test :Function: \"fetch_cards\" (`:= fetch_cards_response`) for board with ID \"68e8befbf2f641caa9b1e275\"\n  - Expect `len(fetch_cards_response.cards)==12`. If `len(fetch_cards_response.cards)<12`, this means that :PaginationIterationRule: was not applied correctly in :Implementation:.\n  - From `fetch_cards_response` (array of objects), find card with \"id\" equal to \"68e8befc8381b0efa25ce1eb\" (`:= specific_card`). Expect:\n    - `specific_card` to exist.\n    - `specific_card.title starts with \"Card1\"`.\n    - `specific_card.body starts with \"This is the description for card\"`.\n    - `specific_card.target_close_date exists`\n    - `specific_card.stage=\"backlog\"`.\n    - `specific_card.item_url_field=\"https://trello.com/c/eNOnhfkI/1-card1-59551f86-4abb-4f27-a93a-c3be5f63cc82\"`.\n    - `specific_card.owned_by_ids==[\"6752eb529b14a3446b75e69c\"]`.\n    - `specific_card.tags=[\"68e8befbf2f641caa9b1e2b8\", \"68e8befbf2f641caa9b1e2b9\", \"68e8befbf2f641caa9b1e2ba\"]`.\n    - `specific_card.trello_due_complete=false`.\n    - `specific_card.trello_position exists`.\n    - `specific_card.state=false`.\n    - `specific_card.modified_date`.\n    - `specific_card.trello_subscribed=true`.\n    - `specific_card.trello_cover_image exist`.\n    - `specific_card.trello_badges exist`.\n    - `specific_card.trello_start_date exists`.",
            "- Test the rate limiting of :Function: \"fetch_cards\" with the following flow:\n  - Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Invoke :Function: \"fetch_cards\" with valid credentials and all required parameters.\n  - Expect: `status_code = 429`.\n  - Expect: `api_delay > 0` and `api_delay <= 3`. If api_delay is bigger than 3, assume the problem is that we did not calculate the api_delay correctly in :Implementation:."
        ],
        "test_summary": [
            {
                "test_name": "should handle rate limiting correctly with status 429 and valid api_delay",
                "test_contents": "This test validates the rate limiting behavior of the fetch_cards function. It starts by initiating rate limiting on the test server for a specific test identifier. Then it loads the fetch_cards event payload with valid Trello credentials and sends it to the snap-in server. The test expects the following outcomes: (1) The snap-in server returns HTTP 200 status, (2) The function_result contains status_code 429 indicating rate limiting was detected, (3) The function_result includes an api_delay field that is a number greater than 0 and less than or equal to 3 seconds, (4) A descriptive error message is present in the response. The test includes detailed error messages that guide developers to check the TrelloClient's handleTrelloError() function in trello-error-handler.ts to ensure it properly extracts the Retry-After header and returns it as api_delay without incorrect conversions or multiplications."
            },
            {
                "test_name": "should fetch all cards with pagination and validate specific card fields",
                "test_contents": "This test validates the complete data extraction and normalization logic for the fetch_cards function with pagination support. It loads the fetch_cards event payload with valid Trello credentials for board ID '68e8befbf2f641caa9b1e275' and sends it to the snap-in server. The test expects: (1) HTTP 200 response with a valid function_result structure, (2) Exactly 12 cards returned, validating that pagination is working correctly according to PaginationIterationRule, (3) A specific card with ID '68e8befc8381b0efa25ce1eb' exists in the results. For this specific card, the test validates all field mappings from the ObjectPRD including: title starts with 'Card1', body starts with 'This is the description for card', target_close_date exists, stage equals 'backlog' (validating StageMappingRule), item_url_field matches the expected Trello URL, owned_by_ids array contains ['6752eb529b14a3446b75e69c'], tags array contains three specific label IDs, trello_due_complete is false, trello_position exists, state is false, modified_date exists, trello_subscribed is true, and custom fields trello_cover_image, trello_badges, and trello_start_date all exist. The test uses helper functions from test-utils.ts to perform assertions with detailed error messages that help identify which specific field mapping or normalization rule failed."
            }
        ]
    },
    "2.2.1": {
        "folder_name": "conformance_tests/fetch_external_sync_units_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_EXTERNAL_SYNC_UNITS_START\":\n  - :ExtractionFunction: should implement the \"external sync units extraction\" part of the extraction workflow as described in the resource `[resource]external-sync-units-extraction.mdx`:\n  - Refer to the resource `[resource]boards-extraction.md` for the mapping from the fields in boards to the fields in :ExternalSyncUnit:.",
        "acceptance_tests": [
            "- Test :ExtractionFunction: using the resource `[resource]trello_external_sync_unit_check.json`.\n  - Expect :TestCallbackServer: to receive *a single* event with \"event_type\" \"EXTRACTION_EXTERNAL_SYNC_UNITS_DONE\".\n  - Let `external_sync_units_array = <event_from_callback_server>[\"event_data\"][\"external_sync_units\"]` (array of objects).\n    - Expect `external_sync_units_array` to exist and be an array.\n    - Expect `len(external_sync_units_array) = 4`.\n    - Out of `external_sync_units_array`, expect that there exists and element that has \"name\" equal to \"SaaS connectors\".",
            "- When the input event is \"EXTRACTION_EXTERNAL_SYNC_UNITS_START\", :ExtractionFunction: must handle rate limiting using the following test flow:\n  - Step 1: Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Step 2: Invoke :ExtractionFunction: using the resource `[resource]trello_external_sync_unit_check.json`.\n    - Expect :TestCallbackServer: to receive *a single* event with \"event_type\" \"EXTRACTION_EXTERNAL_SYNC_UNITS_ERROR\"."
        ],
        "test_summary": [
            {
                "test_name": "External Sync Units Extraction - should extract external sync units and return expected boards",
                "test_contents": "Verify that the snap-in successfully extracts external sync units (Trello boards) and returns them in the correct format"
            },
            {
                "test_name": "External Sync Units Extraction - Rate Limiting - should emit EXTRACTION_EXTERNAL_SYNC_UNITS_ERROR when rate limited",
                "test_contents": "Verify that the snap-in correctly handles HTTP 429 rate limiting responses from Trello API and emits an appropriate error event"
            }
        ]
    },
    "2.2.2": {
        "folder_name": "conformance_tests/extraction_metadata_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_METADATA_START\" :ExtractionFunction: should implement the \"metadata extraction\" part of the extraction workflow as described in the resource `[resource]metadata-extraction.md`.",
        "acceptance_tests": [
            "- Test :ExtractionFunction: using the resource `[resource]metadata_extraction_event.json`.\n  - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_METADATA_DONE\"."
        ],
        "test_summary": [
            {
                "test_name": "should emit EXTRACTION_METADATA_DONE event when metadata extraction succeeds",
                "test_contents": "This test validates the metadata extraction workflow by:\n\n1. Starting a callback server on port 8002 to receive events from DevRev\n2. Reading Trello credentials (API key, OAuth token, organization ID) from environment variables\n3. Loading the metadata extraction event payload from 'metadata-extraction-event.json'\n4. Replacing placeholder credentials in the event payload with actual credentials:\n   - Updates connection_data.key with 'key={apiKey}&token={token}'\n   - Updates connection_data.org_id with the actual organization ID\n5. Sending the prepared event to the snap-in server at http://localhost:8000/handle/sync\n6. Waiting up to 30 seconds for a callback event to be received on the callback server\n7. Verifying that exactly one event is received (not zero, not multiple)\n8. Validating that the received event has event_type='EXTRACTION_METADATA_DONE'\n9. Providing detailed error messages at each stage if failures occur, including:\n   - Credential reading failures\n   - Snap-in communication failures\n   - Callback reception timeouts or count mismatches\n   - Event type mismatches\n\nThe test ensures the complete end-to-end flow of metadata extraction works correctly, from event submission through callback reception, without testing the actual contents of the extracted metadata."
            }
        ]
    },
    "2.2.3": {
        "folder_name": "conformance_tests/extract_users_data_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_DATA_START\" or \"EXTRACTION_DATA_CONTINUE\" :ExtractionFunction: should extract the 'users' data, while preserving previous artifact pushes of data.\n  - Refer to resource `[resource]users-extraction.md` for details on users extraction specification.\n  - Refer to resource `[resource]high-level-data-extraction-plan.md` for:\n    - The order of artifact extraction.\n    - Information if we should use pagination or not for the extraction of the 'users' data.",
        "acceptance_tests": [
            "- Test :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n  - Let `artifact_array = <event_from_callback_server>[\"event_data\"][\"artifacts\"]` (array of objects).\n    - Expect `len(artifact_array) > 0`.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"users\" (`:= users_artifact`) and `users_artifact[\"item_count\"]=3`.\n    - Note: If `users_artifact[\"item_count\"] < 3`, this indicates that not all the users data was extracted.",
            "- When the input event is \"EXTRACTION_DATA_START\", :ExtractionFunction: must handle rate limiting using the following test flow:\n  - Step 1: Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Step 2: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n    - Expect :TestCallbackServer: to receive *a single* event with \"event_type\" \"EXTRACTION_DATA_DELAY\".",
            "- Validate :NormalizationFunction: with :ChefCLI: for the \"users\" record type with the following flow:\n  - Step 1.: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Step 2.: Retrieve full extracted file path (`:= fullExtractedFilePath`)\n    - The extracted file name (`:= extractedFileName`) is the name of the file created by :ExtractionFunction:\n    - extractedFileName is located in the folder provided in the environment variable \"EXTRACTED_FILES_FOLDER_PATH\".\n    - To retrieve extractedFileName, execute the following command: `ls EXTRACTED_FILES_FOLDER_PATH | grep extractor_users | sort -r | head -n 1`\n    - The test should fail the folder \"EXTRACTED_FILES_FOLDER_PATH\" does not exist or if the extractedFileName is not found.\n    - fullExtractedFilePath is the full path to the extractedFileName.\n  - Step 3.: Copy the contents of :ExternalDomainMetadataJSONObject: in a separate :ConformanceTests: file. Contents of :ExternalDomainMetadataJSONObject: JSON object **MUST NOT** be modified compared to the original file contents.\n  - Step 4.: Validate :NormalizationFunction: with :ChefCLI: using the command `\"${CHEF_CLI_PATH}\" validate-data -m <path to :ExternalDomainMetadataJSONObject: file> -r users < <fullExtractedFilePath>`:\n    - Validation is successful precisely when both the stdout and stderr of :ChefCLI: are empty.\n    - Expect the validation of :ChefCLI: to succeed. If it fails, normalization method for \"users\" in :Implementation: should be fixed.\n    - For the validation of :NormalizationFunction: to be successful The :ChefCLI: must return an empty output. Note that the implementation of :ExtractionFunction: directly infuences the output of :ChefCLI:.\n    - The stdout and stderr of :ChefCLI: *MUST* be printed to the console."
        ],
        "test_summary": [
            {
                "test_name": "Data Extraction - Users: should extract users data and emit EXTRACTION_DATA_DONE with correct artifact",
                "test_contents": "This test validates the complete users data extraction workflow:\n\n1. Loads the test payload from 'test-payloads/data_extraction_test.json'\n2. Retrieves Trello credentials from environment variables (TRELLO_API_KEY, TRELLO_TOKEN, TRELLO_ORGANIZATION_ID)\n3. Replaces placeholder credentials in the payload with actual values\n4. Sends EXTRACTION_DATA_START event to the snap-in server at http://localhost:8000/handle/sync\n5. Waits for callback event from DevRev servers (timeout: 90 seconds)\n6. Verifies exactly one callback event was received\n7. Validates event_type is 'EXTRACTION_DATA_DONE'\n8. Confirms event_data exists and contains an artifacts array\n9. Searches for users artifact in the artifacts array (item_type='users')\n10. Verifies users artifact has item_count=3, indicating all users data was successfully extracted\n\nExpected behavior: The extraction function should successfully extract all users from Trello organization, push them to DevRev servers, and emit EXTRACTION_DATA_DONE event with correct artifact information showing 3 users were extracted."
            },
            {
                "test_name": "Data Extraction - Users - Rate Limiting: should emit EXTRACTION_DATA_DELAY when rate limited during users extraction",
                "test_contents": "This test validates proper handling of rate limiting during users extraction:\n\n1. Triggers rate limiting by sending POST request to http://localhost:8004/start_rate_limiting with test identifier\n2. Loads the test payload from 'test-payloads/data_extraction_test.json'\n3. Retrieves Trello credentials from environment variables\n4. Replaces placeholder credentials in the payload with actual values\n5. Sends EXTRACTION_DATA_START event to the snap-in server\n6. Waits for callback event from DevRev servers (timeout: 90 seconds)\n7. Verifies exactly one callback event was received\n8. Validates event_type is 'EXTRACTION_DATA_DELAY' (not EXTRACTION_DATA_DONE or EXTRACTION_DATA_ERROR)\n9. Confirms event_data exists and contains a delay field\n10. Verifies delay is a positive number representing seconds to wait before retrying\n\nExpected behavior: When the Trello API returns HTTP 429 (rate limited) during users extraction, the snap-in should immediately detect this, emit EXTRACTION_DATA_DELAY event with appropriate delay value extracted from the API response, and return without throwing errors. The snap-in must not emit EXTRACTION_DATA_DONE or EXTRACTION_DATA_ERROR in this scenario."
            },
            {
                "test_name": "Normalization Validation - Users: should validate users normalization function with Chef CLI",
                "test_contents": "This test validates that the users normalization function produces valid output according to the external domain metadata specification:\n\n1. Loads the test payload from 'test-payloads/data_extraction_test.json'\n2. Retrieves Trello credentials from environment variables\n3. Replaces placeholder credentials in the payload with actual values\n4. Sends EXTRACTION_DATA_START event to the snap-in server\n5. Waits for callback event and verifies extraction completed successfully (event_type='EXTRACTION_DATA_DONE')\n6. Locates the extracted users data file using EXTRACTED_FILES_FOLDER_PATH environment variable\n7. Searches for the most recent file matching pattern 'extractor_users' in the extracted files folder\n8. Loads the external domain metadata from 'test-metadata/external-domain-metadata.json'\n9. Executes Chef CLI validation command: '<CHEF_CLI_PATH> validate-data -m <metadata_path> -r users < <extracted_file_path>'\n10. Verifies validation succeeded (exit code 0)\n11. Confirms stdout is empty (validation only succeeds when stdout is empty)\n12. Confirms stderr is empty (validation only succeeds when stderr is empty)\n\nExpected behavior: The normalization function should transform raw Trello users data into the format specified by the external domain metadata. Chef CLI validation must pass with both stdout and stderr empty, indicating the normalized data structure, field types, required fields, and data format all conform to the metadata specification. Any output on stdout or stderr indicates validation failure."
            }
        ]
    },
    "2.2.4": {
        "folder_name": "conformance_tests/extract_labels_data_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_DATA_START\" or \"EXTRACTION_DATA_CONTINUE\" :ExtractionFunction: should extract the 'labels' data, while preserving previous artifact pushes of data.\n  - Refer to resource `[resource]labels-extraction.md` for details on labels extraction specification.\n  - Refer to resource `[resource]high-level-data-extraction-plan.md` for:\n    - The order of artifact extraction.\n    - Information if we should use pagination or not for the extraction of the 'labels' data.",
        "acceptance_tests": [
            "- Test :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n  - Let `artifact_array = <event_from_callback_server>[\"event_data\"][\"artifacts\"]` (array of objects).\n    - Expect `len(artifact_array) > 0`.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"labels\" (`:= labels_artifact`) and `labels_artifact[\"item_count\"]=6`.\n    - Note: If `labels_artifact[\"item_count\"] < 6`, this indicates that not all the labels data was extracted.",
            "- When the input event is \"EXTRACTION_DATA_START\", :ExtractionFunction: must handle rate limiting using the following test flow:\n  - Step 1: Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Step 2: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n    - Expect :TestCallbackServer: to receive *a single* event with \"event_type\" \"EXTRACTION_DATA_DELAY\".",
            "- Validate :NormalizationFunction: with :ChefCLI: for the \"labels\" record type with the following flow:\n  - Step 1.: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Step 2.: Retrieve full extracted file path (`:= fullExtractedFilePath`)\n    - The extracted file name (`:= extractedFileName`) is the name of the file created by :ExtractionFunction:\n    - extractedFileName is located in the folder provided in the environment variable \"EXTRACTED_FILES_FOLDER_PATH\".\n    - To retrieve extractedFileName, execute the following command: `ls EXTRACTED_FILES_FOLDER_PATH | grep extractor_labels | sort -r | head -n 1`\n    - The test should fail the folder \"EXTRACTED_FILES_FOLDER_PATH\" does not exist or if the extractedFileName is not found.\n    - fullExtractedFilePath is the full path to the extractedFileName.\n  - Step 3.: Copy the contents of :ExternalDomainMetadataJSONObject: in a separate :ConformanceTests: file. Contents of :ExternalDomainMetadataJSONObject: JSON object **MUST NOT** be modified compared to the original file contents.\n  - Step 4.: Validate :NormalizationFunction: with :ChefCLI: using the command `\"${CHEF_CLI_PATH}\" validate-data -m <path to :ExternalDomainMetadataJSONObject: file> -r labels < <fullExtractedFilePath>`:\n    - Validation is successful precisely when both the stdout and stderr of :ChefCLI: are empty.\n    - Expect the validation of :ChefCLI: to succeed. If it fails, normalization method for \"labels\" in :Implementation: should be fixed.\n    - For the validation of :NormalizationFunction: to be successful The :ChefCLI: must return an empty output. Note that the implementation of :ExtractionFunction: directly infuences the output of :ChefCLI:.\n    - The stdout and stderr of :ChefCLI: *MUST* be printed to the console."
        ],
        "test_summary": [
            {
                "test_name": "Labels Data Extraction - Acceptance Test: should extract exactly 6 labels and report correct item_count in callback",
                "test_contents": "This test validates the end-to-end labels extraction process by:\n1. Starting a callback server on port 8002 to receive extraction events\n2. Loading the test payload from 'data_extraction_test.json' with actual Trello credentials (API key, token, organization ID)\n3. Invoking the snap-in extraction function via HTTP POST to localhost:8000/handle/sync\n4. Waiting for the EXTRACTION_DATA_DONE callback event (timeout: 60 seconds)\n5. Validating that the callback event contains an 'event_data' field with an 'artifacts' array\n6. Finding the 'labels' artifact within the artifacts array by matching item_type='labels'\n7. Verifying that the labels artifact has an 'item_count' field with value exactly 6\n\nExpected outcome: The test passes if exactly 6 labels are extracted and reported in the callback event's item_count field. The test fails with detailed error messages if:\n- The callback event is missing required fields (event_data, artifacts)\n- The artifacts array doesn't contain a labels artifact\n- The item_count is not exactly 6"
            },
            {
                "test_name": "Labels Data Extraction - Normalization Validation: should validate labels data extraction and normalization",
                "test_contents": "This test validates the normalization of extracted labels data by:\n1. Starting a callback server and loading test payload with actual credentials\n2. Invoking the extraction function and waiting for EXTRACTION_DATA_DONE event\n3. Reading the EXTRACTED_FILES_FOLDER_PATH environment variable to locate extracted files\n4. Finding the most recent labels data file matching pattern 'extractor_labels'\n5. Reading and parsing the JSONL file (one JSON object per line)\n6. Validating that at least one label was extracted\n7. For each extracted label, validating:\n   - Top-level required fields: id, created_date, modified_date, data\n   - Field types: id, created_date, modified_date are strings; data is object\n   - Timestamps are valid ISO 8601 format\n   - Data object contains: id, name, color, description fields\n   - ID consistency: data.id matches top-level id\n   - Color format: valid hex code (#RRGGBB) from predefined list of valid colors\n   - Name format: non-empty string, follows 'label-<color>' pattern if applicable\n   - Description format: non-empty array of strings (rich text), matches name\n\nExpected outcome: All extracted labels conform to the normalization rules specified in the labels-extraction.md resource, including proper color hex code conversion, rich text formatting, and field type compliance."
            },
            {
                "test_name": "Labels Data Extraction - Chef CLI Validation: should validate labels normalization using Chef CLI",
                "test_contents": "This test validates labels normalization using the Chef CLI tool by:\n1. Verifying required environment variables are set: EXTRACTED_FILES_FOLDER_PATH and CHEF_CLI_PATH\n2. Checking that the Chef CLI executable exists and is accessible at the specified path\n3. Starting callback server and loading test payload with actual credentials\n4. Invoking the extraction function and waiting for EXTRACTION_DATA_DONE event\n5. Locating the extracted files folder and finding the most recent labels data file using shell command: 'ls | grep extractor_labels | sort -r | head -n 1'\n6. Verifying the labels data file exists and is readable\n7. Locating the external-domain-metadata.json file in test-payloads folder\n8. Executing Chef CLI validation command: '<CHEF_CLI_PATH> validate-data -m <metadata_file> -r labels < <data_file>'\n9. Capturing both stdout and stderr from Chef CLI execution\n10. Validating that both stdout and stderr are completely empty (indicating successful validation)\n\nExpected outcome: The Chef CLI validation passes with no output (empty stdout and stderr), confirming that the normalized labels data conforms to the schema defined in external-domain-metadata.json. If validation fails, the test provides detailed error messages including the full stdout/stderr output and guidance on fixing the normalization function."
            },
            {
                "test_name": "Labels Data Extraction - Rate Limiting Handling: should handle rate limiting and emit EXTRACTION_DATA_DELAY event",
                "test_contents": "This test validates rate limiting handling during labels extraction by:\n1. Starting a callback server on port 8002\n2. Triggering rate limiting on the mock server (localhost:8004) by sending POST request to '/start_rate_limiting' endpoint with test name\n3. Loading test payload with actual Trello credentials\n4. Invoking the extraction function which will encounter rate limiting (HTTP 429)\n5. Waiting for EXTRACTION_DATA_DELAY callback event (timeout: 60 seconds)\n6. Validating the callback event structure:\n   - event_type is 'EXTRACTION_DATA_DELAY'\n   - event_data field exists and is defined\n   - event_data.delay field exists and is defined\n   - delay is a number type\n   - delay is a positive integer (> 0)\n7. Verifying that exactly one callback event was received (no duplicate events)\n\nExpected outcome: When rate limiting is encountered, the snap-in emits exactly one EXTRACTION_DATA_DELAY event with a valid positive integer delay value in seconds. The test fails with detailed error messages if:\n- Rate limiting cannot be triggered on mock server\n- Wrong event type is received\n- Event structure is invalid (missing fields)\n- Delay value is not a positive integer\n- Multiple events are received instead of one"
            }
        ]
    },
    "2.2.5": {
        "folder_name": "conformance_tests/extract_cards_data_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_DATA_START\" or \"EXTRACTION_DATA_CONTINUE\" :ExtractionFunction: should extract the 'cards' data, while preserving previous artifact pushes of data.\n  - Refer to resource `[resource]cards-extraction.md` for details on cards extraction specification.\n  - Refer to resource `[resource]high-level-data-extraction-plan.md` for:\n    - The order of artifact extraction.\n    - Information if we should use pagination or not for the extraction of the 'cards' data.",
        "acceptance_tests": [
            "- Test :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n  - Let `artifact_array = <event_from_callback_server>[\"event_data\"][\"artifacts\"]` (array of objects).\n    - Expect `len(artifact_array) > 0`.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"cards\" (`:= cards_artifact`) and `cards_artifact[\"item_count\"]=12`.\n    - If `cards_artifact[\"item_count\"] < 12`, this indicates that not all the cards data was extracted.\n    - If `cards_artifact[\"item_count\"] < 12` and equals 10, it means :ExtractionFunction: fetched only one page instead of all pages. Pages should be fetched iteratively until all pages are fetched.",
            "- When the input event is \"EXTRACTION_DATA_START\", :ExtractionFunction: must handle rate limiting using the following test flow:\n  - Step 1: Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Step 2: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n    - Expect :TestCallbackServer: to receive *a single* event with \"event_type\" \"EXTRACTION_DATA_DELAY\".",
            "- Validate :NormalizationFunction: with :ChefCLI: for the \"cards\" record type with the following flow:\n  - Step 1.: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Step 2.: Retrieve full extracted file path (`:= fullExtractedFilePath`)\n    - The extracted file name (`:= extractedFileName`) is the name of the file created by :ExtractionFunction:\n    - extractedFileName is located in the folder provided in the environment variable \"EXTRACTED_FILES_FOLDER_PATH\".\n    - To retrieve extractedFileName, execute the following command: `ls EXTRACTED_FILES_FOLDER_PATH | grep extractor_cards | sort -r | head -n 1`\n    - The test should fail the folder \"EXTRACTED_FILES_FOLDER_PATH\" does not exist or if the extractedFileName is not found.\n    - fullExtractedFilePath is the full path to the extractedFileName.\n  - Step 3.: Copy the contents of :ExternalDomainMetadataJSONObject: in a separate :ConformanceTests: file. Contents of :ExternalDomainMetadataJSONObject: JSON object **MUST NOT** be modified compared to the original file contents.\n  - Step 4.: Validate :NormalizationFunction: with :ChefCLI: using the command `\"${CHEF_CLI_PATH}\" validate-data -m <path to :ExternalDomainMetadataJSONObject: file> -r cards < <fullExtractedFilePath>`:\n    - Validation is successful precisely when both the stdout and stderr of :ChefCLI: are empty.\n    - Expect the validation of :ChefCLI: to succeed. If it fails, normalization method for \"cards\" in :Implementation: should be fixed.\n    - For the validation of :NormalizationFunction: to be successful The :ChefCLI: must return an empty output. Note that the implementation of :ExtractionFunction: directly infuences the output of :ChefCLI:.\n    - The stdout and stderr of :ChefCLI: *MUST* be printed to the console."
        ],
        "test_summary": [
            {
                "test_name": "Extract Cards Data - should extract all 12 cards with proper pagination",
                "test_contents": "This test validates that the cards extraction function correctly implements pagination to fetch all cards from a Trello board.\n\nTest Steps:\n1. Read Trello credentials from environment variables (TRELLO_API_KEY, TRELLO_TOKEN, TRELLO_ORGANIZATION_ID)\n2. Setup a callback server on port 8002 to receive events from DevRev\n3. Load the test payload from 'extract_cards_data_payload.json' and replace credential placeholders with actual values\n4. Send an EXTRACTION_DATA_START event to the snap-in server at http://localhost:8000/handle/sync\n5. Wait for a callback event from DevRev (timeout: 100 seconds)\n\nValidations:\n1. Verify that exactly one callback event is received\n2. Verify that the event_type is 'EXTRACTION_DATA_DONE' (not ERROR or DELAY)\n3. Verify that event_data.artifacts is an array with length > 0\n4. Verify that a 'cards' artifact exists in the artifacts array\n5. Verify that the cards artifact has item_count=12 (not 10, which would indicate incomplete pagination)\n\nExpected Behavior:\nThe extraction function should fetch all 12 cards from the test board using pagination with limit=10. This requires at least 2 API calls:\n- First call: fetches 10 cards\n- Second call: fetches remaining 2 cards\nThe function should continue pagination until all cards are retrieved, indicated by receiving fewer cards than the limit.\n\nFailure Scenarios:\n- If item_count=10: Indicates only one page was fetched (incomplete pagination)\n- If item_count<12: Indicates incomplete extraction\n- If item_count>12: Indicates more cards extracted than expected\n- If event_type is not EXTRACTION_DATA_DONE: Indicates extraction failed or was delayed"
            },
            {
                "test_name": "Extract Cards Data - Rate Limiting - should handle rate limiting and emit EXTRACTION_DATA_DELAY event",
                "test_contents": "This test validates that the cards extraction function correctly detects and handles rate limiting (HTTP 429) from the Trello API.\n\nTest Steps:\n1. Read Trello credentials from environment variables\n2. Setup a callback server on port 8002 to receive events from DevRev\n3. Trigger rate limiting by sending a POST request to http://localhost:8004/start_rate_limiting with payload {\"test_name\": \"extract_cards_rate_limiting\"}\n4. Verify that rate limiting was triggered successfully (status 200)\n5. Load the test payload from 'extract_cards_rate_limiting_payload.json' and replace credential placeholders\n6. Send an EXTRACTION_DATA_START event to the snap-in server\n7. Wait for a callback event from DevRev (timeout: 100 seconds)\n\nValidations:\n1. Verify that exactly one callback event is received (not null/undefined)\n2. Verify that event_type is 'EXTRACTION_DATA_DELAY' (not DONE or ERROR)\n3. Verify that event_data exists and contains a 'delay' field\n4. Verify that event_data.delay is a number (not string or other type)\n5. Verify that event_data.delay is greater than 0\n\nExpected Behavior:\nWhen the Trello API returns HTTP 429 (rate limit exceeded), the extraction function must:\n1. Detect the 429 status code immediately after the API call\n2. Extract the delay value from the API response (api_delay field)\n3. Emit ExtractorEventType.ExtractionDataDelay with the delay value\n4. Return immediately without further processing\n\nThis must work for ANY API call during extraction, including:\n- Fetching cards list\n- Fetching card details\n- Fetching comments\n- Fetching attachments\n- Any nested API calls within Promise.all or iterations\n\nFailure Scenarios:\n- If no event received: Rate limiting not detected or event not emitted\n- If event_type is not EXTRACTION_DATA_DELAY: Wrong event emitted (e.g., ERROR or DONE)\n- If delay field is missing: Event emitted without required delay information\n- If delay is not a number or <=0: Invalid delay value"
            },
            {
                "test_name": "Validate Cards Normalization - should validate cards normalization with Chef CLI",
                "test_contents": "This test validates that the cards normalization function produces data that conforms to the external domain metadata schema using the Chef CLI validation tool.\n\nTest Steps:\n1. Read Trello credentials from environment variables\n2. Read EXTRACTED_FILES_FOLDER_PATH environment variable (path to folder where extraction artifacts are stored)\n3. Setup a callback server on port 8002 to receive events from DevRev\n4. Load the test payload from 'validate_cards_normalization_payload.json' and replace credential placeholders\n5. Send an EXTRACTION_DATA_START event to the snap-in server\n6. Wait for EXTRACTION_DATA_DONE callback event (timeout: 100 seconds)\n7. Verify that the event_type is EXTRACTION_DATA_DONE\n8. Verify that CHEF_CLI_PATH environment variable is set\n9. Verify that the extracted files folder exists\n10. Find the most recent cards extraction file using: ls <folder> | grep extractor_cards | sort -r | head -n 1\n11. Verify that the extracted file exists\n12. Verify that external-domain-metadata-copy.json exists in the test directory\n13. Execute Chef CLI validation: <chef_cli_path> validate-data -m <metadata_file> -r cards < <extracted_file>\n14. Capture stdout, stderr, and exit code from Chef CLI\n\nValidations:\n1. Verify that Chef CLI stdout is empty (no validation errors)\n2. Verify that Chef CLI stderr is empty (no validation errors)\n3. If validation fails, provide detailed error information including:\n   - Command executed\n   - Exit code\n   - STDOUT and STDERR output\n   - Sample of extracted data (first 3 lines)\n   - Common issues and how to fix them\n\nExpected Behavior:\nThe normalizeCard function must produce data that matches the schema in external-domain-metadata.json:\n- Required fields: id, created_date, modified_date\n- Field types must match (text, rich_text, timestamp, enum, reference, bool, float)\n- Enum fields (stage) must use only allowed values: backlog, in_development, in_review, completed\n- Rich text fields (body) must be arrays of strings, not plain strings\n- Timestamp fields must be in RFC3339 format\n- Reference fields (owned_by_ids, tags, created_by_id) must contain valid string values\n- Boolean fields (trello_due_complete, state, trello_subscribed) must be true/false\n- Float fields (trello_position) must be valid numbers\n\nCommon Normalization Issues:\n1. Field types do not match (e.g., string instead of array)\n2. Required fields are missing\n3. Enum values are invalid\n4. Rich text fields are not arrays of strings\n5. Timestamp fields are not in RFC3339 format\n6. Reference fields contain invalid values\n\nFailure Scenarios:\n- If EXTRACTED_FILES_FOLDER_PATH not set: Cannot locate extraction artifacts\n- If extracted files folder does not exist: Extraction did not write files\n- If no cards file found: Extraction did not create cards artifact\n- If Chef CLI validation fails: Normalization does not conform to schema"
            }
        ]
    },
    "2.2.6": {
        "folder_name": "conformance_tests/extract_comments_data_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_DATA_START\" or \"EXTRACTION_DATA_CONTINUE\" :ExtractionFunction: should extract the 'comments' data, while preserving previous artifact pushes of data.\n  - Refer to resource `[resource]comments-extraction.md` for details on comments extraction specification.\n  - Refer to resource `[resource]high-level-data-extraction-plan.md` for:\n    - The order of artifact extraction.\n    - Information if we should use pagination or not for the extraction of the 'comments' data.\n  - NOTE: comments should be extracted within extraction of cards",
        "acceptance_tests": [
            "- Test :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n  - Let `artifact_array = <event_from_callback_server>[\"event_data\"][\"artifacts\"]` (array of objects).\n    - Expect `len(artifact_array) > 0`.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"comments\" (`:= comments_artifact`) and `comments_artifact[\"item_count\"]=2`.\n    - Note: If `comments_artifact[\"item_count\"] < 2`, this indicates that not all the comments data was extracted.",
            "- When the input event is \"EXTRACTION_DATA_START\", :ExtractionFunction: must handle rate limiting using the following test flow:\n  - Step 1: Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Step 2: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n    - Expect :TestCallbackServer: to receive *a single* event with \"event_type\" \"EXTRACTION_DATA_DELAY\".",
            "- Validate :NormalizationFunction: with :ChefCLI: for the \"comments\" record type with the following flow:\n  - Step 1.: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Step 2.: Retrieve full extracted file path (`:= fullExtractedFilePath`)\n    - The extracted file name (`:= extractedFileName`) is the name of the file created by :ExtractionFunction:\n    - extractedFileName is located in the folder provided in the environment variable \"EXTRACTED_FILES_FOLDER_PATH\".\n    - To retrieve extractedFileName, execute the following command: `ls EXTRACTED_FILES_FOLDER_PATH | grep extractor_comments | sort -r | head -n 1`\n    - The test should fail the folder \"EXTRACTED_FILES_FOLDER_PATH\" does not exist or if the extractedFileName is not found.\n    - fullExtractedFilePath is the full path to the extractedFileName.\n  - Step 3.: Copy the contents of :ExternalDomainMetadataJSONObject: in a separate :ConformanceTests: file. Contents of :ExternalDomainMetadataJSONObject: JSON object **MUST NOT** be modified compared to the original file contents.\n  - Step 4.: Validate :NormalizationFunction: with :ChefCLI: using the command `\"${CHEF_CLI_PATH}\" validate-data -m <path to :ExternalDomainMetadataJSONObject: file> -r comments < <fullExtractedFilePath>`:\n    - Validation is successful precisely when both the stdout and stderr of :ChefCLI: are empty.\n    - Expect the validation of :ChefCLI: to succeed. If it fails, normalization method for \"comments\" in :Implementation: should be fixed.\n    - For the validation of :NormalizationFunction: to be successful The :ChefCLI: must return an empty output. Note that the implementation of :ExtractionFunction: directly infuences the output of :ChefCLI:.\n    - The stdout and stderr of :ChefCLI: *MUST* be printed to the console."
        ],
        "test_summary": [
            {
                "test_name": "data_extraction_comments_validation",
                "test_contents": "This test validates that comments data is successfully extracted during the data extraction phase.\n\nTest Steps:\n1. Load the test payload from 'data_extraction_test.json' and replace placeholder credentials with actual Trello API credentials (API key, OAuth token, and organization ID)\n2. Send an EXTRACTION_DATA_START event to the snap-in server at http://localhost:8000/handle/sync\n3. Wait for a callback event from the callback server (timeout: 100 seconds)\n4. Verify that exactly one callback event is received\n5. Verify that the event_type is 'EXTRACTION_DATA_DONE'\n6. Verify that event_data.artifacts exists and is a non-empty array\n7. Find the artifact with item_type='comments' in the artifacts array\n8. Verify that the comments artifact has item_count >= 2\n\nExpected Behavior:\n- The snap-in should successfully extract comments data from Trello\n- The callback event should contain an artifacts array with a comments artifact\n- The comments artifact should have at least 2 items, indicating that multiple comments were extracted\n\nFailure Scenarios:\n- If no callback event is received within 100 seconds\n- If more than one callback event is received\n- If the event_type is not 'EXTRACTION_DATA_DONE'\n- If event_data.artifacts is missing or not an array\n- If no artifact with item_type='comments' is found\n- If the comments artifact has item_count < 2"
            },
            {
                "test_name": "data_extraction_rate_limiting_test",
                "test_contents": "This test validates that the snap-in properly handles rate limiting (HTTP 429) responses from the Trello API during data extraction.\n\nTest Steps:\n1. Trigger rate limiting on the rate limiting server by sending a POST request to http://localhost:8004/start_rate_limiting with test_name='data_extraction_rate_limiting_test'\n2. Verify that the rate limiting server responds with status code 200\n3. Load the test payload from 'data_extraction_test.json' and replace placeholder credentials with actual Trello API credentials\n4. Send an EXTRACTION_DATA_START event to the snap-in server at http://localhost:8000/handle/sync\n5. Wait for a callback event from the callback server (timeout: 100 seconds)\n6. Verify that exactly one callback event is received\n7. Verify that the event_type is 'EXTRACTION_DATA_DELAY'\n8. Verify that event_data exists and contains a 'delay' field\n9. Verify that the delay value is a positive number (either number or string type)\n\nExpected Behavior:\n- When the Trello API returns a 429 status code, the snap-in should detect it immediately\n- The snap-in should extract the delay value from the API response\n- The snap-in should emit a single EXTRACTION_DATA_DELAY event with the delay value\n- The snap-in should not continue processing or emit any other events\n\nFailure Scenarios:\n- If the rate limiting server fails to start rate limiting\n- If no callback event is received within 100 seconds\n- If more than one callback event is received (indicating improper handling)\n- If the event_type is not 'EXTRACTION_DATA_DELAY'\n- If event_data or event_data.delay is missing\n- If the delay value is not a positive number"
            },
            {
                "test_name": "comments_normalization_chef_cli_validation",
                "test_contents": "This test validates that the extracted comments data is properly normalized according to the schema defined in external-domain-metadata.json using the Chef CLI validation tool.\n\nTest Steps:\n1. Load the test payload from 'data_extraction_test.json' and replace placeholder credentials with actual Trello API credentials\n2. Send an EXTRACTION_DATA_START event to the snap-in server at http://localhost:8000/handle/sync\n3. Wait for a callback event from the callback server (timeout: 100 seconds)\n4. Verify that exactly one callback event is received with event_type='EXTRACTION_DATA_DONE'\n5. Get the extracted files folder path from the EXTRACTED_FILES_FOLDER_PATH environment variable\n6. Find the most recent comments extraction file (matching pattern 'extractor_comments')\n7. Verify that the extracted comments file exists\n8. Get the Chef CLI executable path from the CHEF_CLI_PATH environment variable\n9. Copy external-domain-metadata.json from the build folder to the test directory\n10. Execute Chef CLI validation command: 'chef-cli validate-data -m external-domain-metadata-copy.json -r comments < comments_file'\n11. Clean up the metadata copy file\n12. Verify that the validation succeeded (exit code 0, empty stdout and stderr)\n\nExpected Normalization Requirements:\n- Required top-level fields: id, created_date, modified_date, data\n- Field types must match schema (id/created_date/modified_date are strings, data is object)\n- Timestamps must be in RFC3339 format\n- data object must contain: id, body, parent_object_id, created_by_id, modified_date, grandparent_object_id, grandparent_object_type, creator_display_name, parent_object_type\n- body field must be array of strings (rich text format), not plain string\n- parent_object_id must reference a valid card ID\n- created_by_id must reference a valid user ID\n- grandparent_object_type must be fixed value 'board'\n- parent_object_type must be fixed value 'issue'\n- All reference fields must contain valid string values\n\nFailure Scenarios:\n- If the extracted comments file is not found\n- If the external-domain-metadata.json file is not found in the build folder\n- If Chef CLI validation fails (non-zero exit code or non-empty stdout/stderr)\n- Common normalization issues include: body field as plain string instead of array, timestamps not in RFC3339 format, missing required fields, incorrect field types, incorrect fixed values, rich text conversion not applied"
            }
        ]
    },
    "2.2.7": {
        "folder_name": "conformance_tests/extract_attachments_data_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_DATA_START\" or \"EXTRACTION_DATA_CONTINUE\" :ExtractionFunction: should extract the 'attachments' data, while preserving previous artifact pushes of data.\n  - Refer to resource `[resource]attachments-extraction.md` for details on attachments extraction specification.\n  - Refer to resource `[resource]high-level-data-extraction-plan.md` for:\n    - The order of artifact extraction.\n    - Information if we should use pagination or not for the extraction of the 'attachments' data.\n  - NOTE: attachments should be extracted within extraction of cards",
        "acceptance_tests": [
            "- Test :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n  - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n  - Let `artifact_array = <event_from_callback_server>[\"event_data\"][\"artifacts\"]` (array of objects).\n    - Expect `len(artifact_array) > 0`.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"attachments\" (`:= attachments_artifact`) and `attachments_artifact[\"item_count\"]=2`.\n    - Note: If `attachments_artifact[\"item_count\"] < 2`, this indicates that not all the attachments data was extracted.",
            "- When the input event is \"EXTRACTION_DATA_START\", :ExtractionFunction: must handle rate limiting using the following test flow:\n  - Step 1: Make a POST request to \"http://localhost:8004/start_rate_limiting\" with body `{ \"test_name\": <identifyer of the test>}`.\n  - Step 2: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n    - Expect :TestCallbackServer: to receive *a single* event with \"event_type\" \"EXTRACTION_DATA_DELAY\"."
        ],
        "test_summary": [
            {
                "test_name": "data_extraction_attachments_validation",
                "test_contents": "This test validates that attachments are correctly extracted during the data extraction phase.\n\nTest Steps:\n1. Load test payload from 'data_extraction_test.json' and replace placeholder credentials with actual Trello API credentials from environment variables (TRELLO_API_KEY, TRELLO_TOKEN, TRELLO_ORGANIZATION_ID)\n2. Send EXTRACTION_DATA_START event to snap-in server at http://localhost:8000/handle/sync\n3. Wait for callback event from snap-in (timeout: 100 seconds)\n4. Verify callback event is received\n5. Verify event_type is 'EXTRACTION_DATA_DONE'\n6. Verify artifacts array exists in event_data\n7. Verify artifacts array is not empty\n8. Find attachments artifact (item_type = 'attachments') in artifacts array\n9. Verify attachments artifact item_count equals 2 (expected number of attachments from card '68e8befc8381b0efa25ce1eb')\n\nExpected Outcome:\n- Callback event with event_type 'EXTRACTION_DATA_DONE' is received\n- Artifacts array contains an artifact with item_type 'attachments'\n- Attachments artifact has item_count = 2\n\nThis test ensures that the snap-in correctly extracts attachments from Trello cards and reports the correct count in the callback event."
            },
            {
                "test_name": "attachments_normalization_validation",
                "test_contents": "This test validates that extracted attachments are correctly normalized according to the external domain metadata schema.\n\nTest Steps:\n1. Load test payload from 'data_extraction_test.json' and replace placeholder credentials with actual Trello API credentials\n2. Send EXTRACTION_DATA_START event to snap-in server\n3. Wait for callback event (timeout: 100 seconds)\n4. Verify callback event is received with event_type 'EXTRACTION_DATA_DONE'\n5. Locate the most recent attachments extraction file in EXTRACTED_FILES_FOLDER_PATH (environment variable)\n6. Read and parse the attachments file (JSONL format)\n7. Validate each attachment line against normalization requirements:\n   - Top-level fields: id (string), created_date (string, RFC3339 format), modified_date (string, RFC3339 format), data (object)\n   - data object fields: id (string), url (valid URL string), file_name (non-empty string), parent_id (string, card ID reference)\n   - Optional data fields: author_id (string or null, user ID reference)\n   - URL construction validation: URLs starting with 'https://trello.com' should be transformed to 'https://api.trello.com/1/cards/{idCard}/attachments/{idAttachment}/download/{fileName}' format\n8. Collect all validation errors and report them if any exist\n\nExpected Outcome:\n- All attachments in the extracted file pass normalization validation\n- No validation errors are found\n- Each attachment has all required fields with correct types and formats\n- Trello URLs are correctly transformed to download URLs according to URLConstructionRule\n\nThis test ensures that the normalization function correctly transforms raw Trello attachment data into the format expected by DevRev's domain metadata schema."
            },
            {
                "test_name": "data_extraction_rate_limiting_validation",
                "test_contents": "This test validates that the snap-in correctly handles rate limiting (HTTP 429) during data extraction.\n\nTest Steps:\n1. Load test payload from 'data_extraction_test.json' and replace placeholder credentials with actual Trello API credentials\n2. Trigger rate limiting by sending POST request to http://localhost:8004/start_rate_limiting with test name\n3. Verify rate limiting was triggered successfully (status 200)\n4. Send EXTRACTION_DATA_START event to snap-in server\n5. Wait for callback event (timeout: 100 seconds)\n6. Verify callback event is received\n7. Verify exactly one callback event was received (no retries or multiple emissions)\n8. Verify event_type is 'EXTRACTION_DATA_DELAY'\n9. Verify event_data object exists\n10. Verify delay field exists in event_data\n11. Verify delay is a positive integer (representing seconds)\n\nExpected Outcome:\n- Exactly one callback event is received\n- Event type is 'EXTRACTION_DATA_DELAY'\n- event_data.delay is a positive integer\n- No multiple events or retries occur\n\nThis test ensures that when the Trello API returns HTTP 429 (rate limit exceeded), the snap-in:\n- Detects the rate limiting condition\n- Emits exactly one EXTRACTION_DATA_DELAY event\n- Includes a valid delay value (positive integer) extracted from the API response\n- Does not retry or emit multiple events\n- Follows the data extraction rules for rate limiting as specified in the documentation"
            }
        ]
    },
    "2.2.8": {
        "folder_name": "conformance_tests/extract_attachments_streaming_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_ATTACHMENTS_START\" or \"EXTRACTION_ATTACHMENTS_CONTINUE\" :ExtractionFunction: should implement attachment streaming.\n  - Refer to resource `[resource]attachments-extraction-guide.md` for general guidelines on attachment streaming.\n  - Refer to resource `[resource]attachments-extraction.md` for specifics about extraction from :API:.\n  - Refer to resource `[resource]attachments_normalization.md` for information about normalization of attachments.",
        "acceptance_tests": [
            "- Test :ExtractionFunction: with the following flow (`:= attachmentTestFlow`):\n  - Step 1: Invoke :ExtractionFunction: using the resource `[resource]data_extraction_test.json`.\n    - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n  - Step 2: Invoke :ExtractionFunction: using the resource `[resource]attachments_extraction_test.json`.\n    - Expect :TestCallbackServer: to receive from DevRev a **single** event (`:= event_from_callback_server`) with \"event_type\" that equals \"EXTRACTION_ATTACHMENTS_DONE\".\n    - Expect `event_from_callback_server[\"event_data\"][\"artifacts\"]` to be an array. Expect this array to not be empty. Expect this array to have length 1.\n    - Let `artifact_object = event_from_callback_server[\"event_data\"][\"artifacts\"][0]`.\n      - Expect `artifact_object[\"item_type\"] = \"ssor_attachment\"` and `artifact_object[\"item_count\"] = 2`.\n      - Make a GET request to \"http://localhost:8003/is_uploaded/{artifact_object['id']}\". Expect response code to be equal to 200.\n  - Note: attachmentTestFlow should be executed within a single test.",
            "- Test :ExtractionFunction: using the resource `[resource]attachments_extraction_continue_test.json`.\n  - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_ATTACHMENTS_DONE\"."
        ],
        "test_summary": [
            {
                "test_name": "attachmentTestFlow",
                "test_contents": "This test validates the complete attachment extraction workflow in two phases:\n\nPhase 1 - Data Extraction:\n- Sends EXTRACTION_DATA_START event to extract card data including attachment metadata\n- Waits for EXTRACTION_DATA_DONE callback event\n- Verifies exactly one callback event was received\n- Clears events before proceeding to attachment streaming\n\nPhase 2 - Attachment Streaming:\n- Sends EXTRACTION_ATTACHMENTS_START event to stream attachments\n- Waits for callback event with 120-second timeout\n- Validates exactly one callback event was received\n- Verifies event_type is EXTRACTION_ATTACHMENTS_DONE\n- Validates event_data and artifacts array exist\n- Confirms artifacts array has exactly 1 element with at least 1 attachment\n- Validates artifact properties: item_type='ssor_attachment', item_count=2, id is non-empty string\n- Verifies the artifact was successfully uploaded to DevRev servers by calling the verification endpoint"
            },
            {
                "test_name": "attachments_extraction_continue_success",
                "test_contents": "This test validates the EXTRACTION_ATTACHMENTS_CONTINUE event handling:\n\n- Loads test payload from attachments_extraction_continue_test.json\n- Invokes the snap-in with EXTRACTION_ATTACHMENTS_CONTINUE event type\n- Waits for callback event with 120-second timeout\n- Validates exactly one callback event was received\n- Verifies the event_type is EXTRACTION_ATTACHMENTS_DONE\n\nThis ensures that when attachment streaming is continued (after a previous interruption or progress event), the extraction function properly resumes and completes the attachment streaming process."
            },
            {
                "test_name": "attachments_extraction_rate_limiting",
                "test_contents": "This test validates rate limiting handling during attachment streaming in three phases:\n\nPhase 1 - Data Extraction (No Rate Limiting):\n- Sends EXTRACTION_DATA_START event to extract card data\n- Waits for EXTRACTION_DATA_DONE callback\n- Verifies the data extraction completed successfully\n\nPhase 2 - Trigger Rate Limiting:\n- Calls triggerRateLimiting endpoint with test identifier 'attachments_extraction_rate_limiting'\n- Verifies rate limiting was successfully activated\n- Clears callback events before attachment streaming\n\nPhase 3 - Attachment Streaming (With Rate Limiting):\n- Sends EXTRACTION_ATTACHMENTS_START event\n- Waits for callback event with 120-second timeout\n- Validates exactly one callback event was received\n- Verifies event_type is EXTRACTION_ATTACHMENTS_DELAY (not DONE)\n- Validates event_data exists and contains a delay field\n- Confirms delay is a positive number\n\nThis ensures the extraction function properly detects rate limiting (HTTP 429) during attachment streaming and emits the appropriate EXTRACTION_ATTACHMENTS_DELAY event with a delay value."
            }
        ]
    },
    "2.2.9": {
        "folder_name": "conformance_tests/incremental_sync_tests",
        "functional_requirement": "- If \"event_type\" equals \"EXTRACTION_DATA_START\" and \"mode\" equals \"SyncMode.INCREMENTAL\", :ExtractionFunction: should support incremental data synchronization.\n  - Refer to resource `[resource]incremental-mode-prd.md` for:\n    - Which :ArtifactName:s support incremental mode.\n    - How to implement incremental mode for the given :ArtifactName:.\n  - Refer to resource `[resource]incremental_mode.md` for a generic guide for incremental mode implementation.",
        "acceptance_tests": [
            "- Validate the incremental mode with the following flow:\n  - Step 1:\n    - Execute request `curl -X POST \"http://localhost:8003/external-worker.update-last-successful-sync/<sync_unit_id>\" -H \"Content-Type: application/json\" -d '{\"snap_in_version_id\":\"test-version-id\",\"extend_state\": <:CompleteExtractionStateObject:>}'`\n      - `<sync_unit_id>` is `event[\"payload\"][\"event_context\"][\"sync_unit_id\"]` in the resource `[resource]data_extraction_incremental_test.json`.\n      - `<:CompleteExtractionStateObject:>` is complete state of :TrelloExtractionStateObject: in JSON format.\n  - Step 2:\n    - Execute request `curl --request PUT --url 'https://api.trello.com/1/cards/68e8bf05096269b58d94f3d9?key=<TRELLO_API_KEY>&token=<TRELLO_TOKEN>&name=\"Card12-<uuid>\"' --header 'Accept: application/json'` (replace <TRELLO_API_KEY>, <TRELLO_TOKEN> and <uuid> with the actual values).\n    - Expect the request to succeed.\n  - Step 3:\n    - Invoke :ExtractionFunction: using the resource `[resource]data_extraction_incremental_test.json`.\n    - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n    - Let `artifact_array = <event_from_callback_server>[\"event_data\"][\"artifacts\"]` (array of objects).\n    - Expect `artifact_array` to not be empty array.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"cards\" (`:= cards_artifact`). Expect `cards_artifact[\"item_count\"]=1`.\n    - Expect that there is no element in `artifact_array` with \"item_type\" equal to \"attachments\". If there is, this indicates that the attachments data was pushed to the DevRev servers, which is wrong.\n    - Expect that there is no element in `artifact_array` with \"item_type\" equal to \"users\". If there is, this indicates that the users data was pushed to the DevRev servers, which is wrong.",
            "- Validate the incremental mode with the following flow:\n  - Step 1:\n    - Execute request `curl -X POST \"http://localhost:8003/external-worker.update-last-successful-sync/<sync_unit_id>\" -H \"Content-Type: application/json\" -d '{\"snap_in_version_id\":\"test-version-id\",\"extend_state\": <:CompleteExtractionStateObject:>}'`\n      - `<sync_unit_id>` is `event[\"payload\"][\"event_context\"][\"sync_unit_id\"]` in the resource `[resource]data_extraction_incremental_test.json`.\n      - `<:CompleteExtractionStateObject:>` is complete state of :TrelloExtractionStateObject: in JSON format.\n  - Step 2:\n    - Execute request `curl --request PUT --url 'https://api.trello.com/1/cards/68e8befc8381b0efa25ce1eb?key=<TRELLO_API_KEY>&token=<TRELLO_TOKEN>&name=\"Card1-<uuid>\"' --header 'Accept: application/json'` (replace <TRELLO_API_KEY>, <TRELLO_TOKEN> and <uuid> with the actual values).\n    - Expect the request to succeed.\n  - Step 3:\n    - Invoke :ExtractionFunction: using the resource `[resource]data_extraction_incremental_test.json`.\n    - Expect :TestCallbackServer: to receive from DevRev a **single** event with \"event_type\" that equals \"EXTRACTION_DATA_DONE\".\n    - Let `artifact_array = <event_from_callback_server>[\"event_data\"][\"artifacts\"]` (array of objects).\n    - Expect `artifact_array` to not be empty array.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"cards\" (`:= cards_artifact`). Expect `cards_artifact[\"item_count\"]=1`.\n    - Out of `artifact_array`, expect one of the elements to have \"item_type\" equal to \"attachments\" (`:= attachments_artifact`). Expect `attachments_artifact[\"item_count\"]=2`.\n    - Expect that there is no element in `artifact_array` with \"item_type\" equal to \"users\". If there is, this indicates that the users data was pushed to :DevRevServers:, which is wrong."
        ],
        "test_summary": [
            {
                "test_name": "Incremental Data Synchronization - should extract only modified cards and their attachments in incremental mode",
                "test_contents": "This test validates that incremental data synchronization correctly extracts only modified cards and their associated attachments, while skipping unchanged resources like users and labels.\n\nTest Steps:\n1. Set Complete Extraction State: Updates the sync unit state to indicate that all resources (users, labels, cards, comments, attachments) have been previously extracted successfully.\n\n2. Modify a Trello Card: Updates a specific Trello card (ID: 68e8befc8381b0efa25ce1eb) with a new name containing a UUID to ensure the card is marked as modified after the last successful sync.\n\n3. Invoke Extraction Function: Sets up a callback server on port 8002 and invokes the extraction function with an EXTRACTION_DATA_START event in INCREMENTAL mode, then waits for the callback response (60-second timeout).\n\n4. Validate Callback Response:\n   - Asserts exactly one callback event is received\n   - Verifies the event_type is 'EXTRACTION_DATA_DONE'\n   - Confirms the event_data.artifacts array exists and is not empty\n   - Validates that a 'cards' artifact exists with item_count=1 (only the modified card)\n   - Validates that an 'attachments' artifact exists with item_count=2 (attachments from the modified card)\n   - Ensures no 'users' artifact is present (users should not be re-extracted in incremental mode)\n   - Ensures no 'labels' artifact is present (labels should not be re-extracted in incremental mode)\n\nExpected Outcome:\n- Only the modified card is extracted (1 card)\n- Only attachments belonging to the modified card are extracted (2 attachments)\n- Users and labels are not re-extracted in incremental mode\n- The extraction completes successfully with EXTRACTION_DATA_DONE event"
            }
        ]
    }
}